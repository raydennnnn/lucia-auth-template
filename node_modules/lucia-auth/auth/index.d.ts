import { Cookie, CookieOption } from "./cookie.js";
import { AuthRequest } from "./request.js";
import { lucia as defaultMiddleware } from "../middleware/index.js";
import type { UserSchema } from "./schema.js";
import type { Adapter, UserAdapter, SessionAdapter } from "./adapter.js";
import type { LuciaErrorConstructor } from "./error.js";
import type { Middleware, LuciaRequest } from "./request.js";
export type Session = Readonly<{
    sessionId: string;
    userId: string;
    activePeriodExpiresAt: Date;
    idlePeriodExpiresAt: Date;
    state: "idle" | "active";
    fresh: boolean;
}>;
export type Key = SingleUseKey | PersistentKey;
export type SingleUseKey = Readonly<{
    type: "single_use";
    userId: string;
    providerId: string;
    providerUserId: string;
    passwordDefined: boolean;
    expiresAt: Date;
    expired: boolean;
}>;
export type PersistentKey = Readonly<{
    type: "persistent";
    userId: string;
    providerId: string;
    providerUserId: string;
    passwordDefined: boolean;
    primary: boolean;
}>;
export type Env = "DEV" | "PROD";
export type User = ReturnType<Lucia.Auth["_transformDatabaseUser"]>;
export declare const lucia: <C extends Configuration>(config: C) => Auth<C>;
export declare class Auth<C extends Configuration = any> {
    private adapter;
    private generateUserId;
    private sessionCookieOption;
    private sessionExpiresIn;
    private env;
    private hash;
    private autoDatabaseCleanup;
    protected middleware: C["middleware"] extends Middleware ? C["middleware"] : ReturnType<typeof defaultMiddleware>;
    private csrfProtection;
    private origin;
    private experimental;
    constructor(config: C);
    protected _transformDatabaseUser: (databaseUser: UserSchema) => C["transformDatabaseUser"] extends Function ? ReturnType<C["transformDatabaseUser"]> : {
        userId: string;
    };
    transformDatabaseUser: (databaseUser: UserSchema) => User;
    getUser: (userId: string) => Promise<User>;
    getSessionUser: (sessionId: string) => Promise<{
        user: User;
        session: Session;
    }>;
    createUser: (data: {
        primaryKey: {
            providerId: string;
            providerUserId: string;
            password: string | null;
        } | null;
        attributes: Lucia.UserAttributes;
    }) => Promise<User>;
    updateUserAttributes: (userId: string, attributes: Partial<Lucia.UserAttributes>) => Promise<User>;
    deleteUser: (userId: string) => Promise<void>;
    useKey: (providerId: string, providerUserId: string, password: string | null) => Promise<Key>;
    getSession: (sessionId: string) => Promise<Session>;
    getAllUserSessions: (userId: string) => Promise<Session[]>;
    validateSession: (sessionId: string) => Promise<Session>;
    validateSessionUser: (sessionId: string) => Promise<{
        session: Session;
        user: User;
    }>;
    generateSessionId: () => readonly [sessionId: string, activePeriodExpiresAt: Date, idlePeriodExpiresAt: Date];
    createSession: (userId: string) => Promise<Session>;
    renewSession: (sessionId: string) => Promise<Session>;
    invalidateSession: (sessionId: string) => Promise<void>;
    invalidateAllUserSessions: (userId: string) => Promise<void>;
    deleteDeadUserSessions: (userId: string) => Promise<void>;
    parseRequestHeaders: (request: LuciaRequest) => string | null;
    handleRequest: (...args: (C["middleware"] extends Middleware ? C["middleware"] : Middleware<[import("./request.js").RequestContext]>) extends Middleware<infer Args extends any[]> ? Args : never) => AuthRequest<Lucia.Auth>;
    createSessionCookie: (session: Session | null) => Cookie;
    createKey: <KeyData extends {
        readonly type: PersistentKey["type"];
        providerId: string;
        providerUserId: string;
        password: string | null;
    } | {
        readonly type: SingleUseKey["type"];
        providerId: string;
        providerUserId: string;
        password: string | null;
        expiresIn: number;
    }>(userId: string, keyData: KeyData) => Promise<GetKeyFromKeyType<KeyData["type"]>>;
    deleteKey: (providerId: string, providerUserId: string) => Promise<void>;
    getKey: (providerId: string, providerUserId: string) => Promise<Key>;
    getAllUserKeys: (userId: string) => Promise<Key[]>;
    updateKeyPassword: (providerId: string, providerUserId: string, password: string | null) => Promise<void>;
}
type MaybePromise<T> = T | Promise<T>;
export type Configuration = {
    adapter: ((E: LuciaErrorConstructor) => Adapter) | {
        user: (E: LuciaErrorConstructor) => UserAdapter | Adapter;
        session: (E: LuciaErrorConstructor) => SessionAdapter | Adapter;
    };
    env: Env;
    autoDatabaseCleanup?: boolean;
    csrfProtection?: boolean;
    generateCustomUserId?: () => MaybePromise<string>;
    hash?: {
        generate: (s: string) => MaybePromise<string>;
        validate: (s: string, hash: string) => MaybePromise<boolean>;
    };
    middleware?: Middleware;
    origin?: string[];
    sessionExpiresIn?: {
        activePeriod: number;
        idlePeriod: number;
    };
    sessionCookie?: CookieOption;
    transformDatabaseUser?: (databaseUser: Required<UserSchema>) => Record<string, any>;
    experimental?: {
        debugMode?: boolean;
    };
};
type GetKeyFromKeyType<Type extends string> = Type extends PersistentKey["type"] ? PersistentKey : Type extends SingleUseKey["type"] ? SingleUseKey : never;
export {};
