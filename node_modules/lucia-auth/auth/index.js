import { SESSION_COOKIE_NAME, createSessionCookie } from "./cookie.js";
import { logError } from "../utils/log.js";
import { generateScryptHash, validateScryptHash } from "../utils/crypto.js";
import { generateRandomString } from "../utils/nanoid.js";
import { LuciaError } from "./error.js";
import { parseCookie } from "../utils/cookie.js";
import { validateDatabaseSession } from "./session.js";
import { transformDatabaseKey, getOneTimeKeyExpiration } from "./key.js";
import { isWithinExpiration } from "../utils/date.js";
import { AuthRequest } from "./request.js";
import { lucia as defaultMiddleware } from "../middleware/index.js";
import { debug } from "../utils/debug.js";
export const lucia = (config) => {
    return new Auth(config);
};
const validateConfiguration = (config) => {
    const adapterProvided = config.adapter;
    if (!adapterProvided) {
        logError('Adapter is not defined in configuration ("config.adapter")');
        process.exit(1);
    }
};
export class Auth {
    adapter;
    generateUserId;
    sessionCookieOption;
    sessionExpiresIn;
    env;
    hash;
    autoDatabaseCleanup;
    middleware;
    csrfProtection;
    origin;
    experimental;
    constructor(config) {
        validateConfiguration(config);
        const defaultSessionCookieOption = {
            sameSite: "lax",
            path: "/"
        };
        if ("user" in config.adapter) {
            let userAdapter = config.adapter.user(LuciaError);
            let sessionAdapter = config.adapter.session(LuciaError);
            if ("getSessionAndUserBySessionId" in userAdapter) {
                const { getSessionAndUserBySessionId: _, ...extractedUserAdapter } = userAdapter;
                userAdapter = extractedUserAdapter;
            }
            if ("getSessionAndUserBySessionId" in sessionAdapter) {
                const { getSessionAndUserBySessionId: _, ...extractedSessionAdapter } = sessionAdapter;
                sessionAdapter = extractedSessionAdapter;
            }
            this.adapter = {
                ...userAdapter,
                ...sessionAdapter
            };
        }
        else {
            this.adapter = config.adapter(LuciaError);
        }
        this.generateUserId =
            config.generateCustomUserId ?? (() => generateRandomString(15));
        this.env = config.env;
        this.csrfProtection = config.csrfProtection ?? true;
        this.sessionExpiresIn = {
            activePeriod: config.sessionExpiresIn?.activePeriod ?? 1000 * 60 * 60 * 24,
            idlePeriod: config.sessionExpiresIn?.idlePeriod ?? 1000 * 60 * 60 * 24 * 14
        };
        this.autoDatabaseCleanup = config.autoDatabaseCleanup ?? true;
        this._transformDatabaseUser = (databaseUser) => {
            const defaultTransform = ({ id }) => {
                return {
                    userId: id
                };
            };
            const transform = config.transformDatabaseUser ?? defaultTransform;
            return transform(databaseUser);
        };
        this.sessionCookieOption =
            config.sessionCookie ?? defaultSessionCookieOption;
        this.hash = {
            generate: config.hash?.generate ?? generateScryptHash,
            validate: config.hash?.validate ?? validateScryptHash
        };
        this.middleware = config.middleware ?? defaultMiddleware();
        this.origin = config.origin ?? [];
        this.experimental = {
            debugMode: config.experimental?.debugMode ?? false
        };
        debug.init(this.experimental.debugMode);
    }
    _transformDatabaseUser;
    transformDatabaseUser = (databaseUser) => {
        return this._transformDatabaseUser(databaseUser);
    };
    getUser = async (userId) => {
        const databaseUser = await this.adapter.getUser(userId);
        if (!databaseUser) {
            throw new LuciaError("AUTH_INVALID_USER_ID");
        }
        const user = this.transformDatabaseUser(databaseUser);
        return user;
    };
    getSessionUser = async (sessionId) => {
        if (sessionId.length !== 40) {
            debug.session.fail("Expected id length to be 40", sessionId);
            throw new LuciaError("AUTH_INVALID_SESSION_ID");
        }
        let databaseUser;
        let databaseSession;
        if (this.adapter.getSessionAndUserBySessionId !== undefined) {
            const databaseUserSession = await this.adapter.getSessionAndUserBySessionId(sessionId);
            if (!databaseUserSession) {
                debug.session.fail("Session not found", sessionId);
                throw new LuciaError("AUTH_INVALID_SESSION_ID");
            }
            databaseUser = databaseUserSession.user;
            databaseSession = databaseUserSession.session;
        }
        else {
            databaseSession = await this.adapter.getSession(sessionId);
            if (!databaseSession) {
                debug.session.fail("Session not found", sessionId);
                throw new LuciaError("AUTH_INVALID_SESSION_ID");
            }
            databaseUser = await this.adapter.getUser(databaseSession.user_id);
            if (!databaseUser) {
                debug.session.fail("User not found", databaseSession.user_id);
                throw new LuciaError("AUTH_INVALID_SESSION_ID");
            }
        }
        const session = validateDatabaseSession(databaseSession);
        if (!session) {
            debug.session.fail(`Session expired at ${new Date(Number(databaseSession.idle_expires))}`, sessionId);
            if (this.autoDatabaseCleanup) {
                await this.adapter.deleteSession(sessionId);
            }
            throw new LuciaError("AUTH_INVALID_SESSION_ID");
        }
        return {
            user: this.transformDatabaseUser(databaseUser),
            session
        };
    };
    createUser = async (data) => {
        const userId = await this.generateUserId();
        const userAttributes = data.attributes ?? {};
        if (data.primaryKey === null) {
            const databaseUser = await this.adapter.setUser(userId, userAttributes, null);
            if (databaseUser)
                return this.transformDatabaseUser(databaseUser);
            return await this.getUser(userId);
        }
        const keyId = `${data.primaryKey.providerId}:${data.primaryKey.providerUserId}`;
        const password = data.primaryKey.password;
        const hashedPassword = password ? await this.hash.generate(password) : null;
        const databaseUser = await this.adapter.setUser(userId, userAttributes, {
            id: keyId,
            user_id: userId,
            hashed_password: hashedPassword,
            primary_key: true,
            expires: null
        });
        if (databaseUser)
            return this.transformDatabaseUser(databaseUser);
        return await this.getUser(userId);
    };
    updateUserAttributes = async (userId, attributes) => {
        const [updatedDatabaseUser] = await Promise.all([
            this.adapter.updateUserAttributes(userId, attributes),
            this.autoDatabaseCleanup
                ? await this.deleteDeadUserSessions(userId)
                : null
        ]);
        if (updatedDatabaseUser)
            return this.transformDatabaseUser(updatedDatabaseUser);
        return await this.getUser(userId);
    };
    deleteUser = async (userId) => {
        await this.adapter.deleteSessionsByUserId(userId);
        await this.adapter.deleteKeysByUserId(userId);
        await this.adapter.deleteUser(userId);
    };
    useKey = async (providerId, providerUserId, password) => {
        const keyId = `${providerId}:${providerUserId}`;
        // TODO: remove check in v2
        const shouldDataBeDeleted = async (data) => {
            const persistentKey = data.expires === null;
            if (persistentKey)
                return false;
            if (data.hashed_password === null)
                return true;
            if (password === null)
                return false;
            return await this.hash.validate(password, data.hashed_password);
        };
        const databaseKeyData = await this.adapter.getKey(keyId, shouldDataBeDeleted);
        if (!databaseKeyData) {
            debug.key.fail("Key not found", keyId);
            throw new LuciaError("AUTH_INVALID_KEY_ID");
        }
        try {
            const singleUse = !!databaseKeyData.expires;
            const hashedPassword = databaseKeyData.hashed_password;
            if (hashedPassword) {
                debug.key.info("Key includes password");
                if (!password) {
                    debug.key.fail("Key password not provided", keyId);
                    throw new LuciaError("AUTH_INVALID_PASSWORD");
                }
                if (hashedPassword.startsWith("$2a")) {
                    throw new LuciaError("AUTH_OUTDATED_PASSWORD");
                }
                const validPassword = await this.hash.validate(password, hashedPassword);
                if (!validPassword) {
                    debug.key.fail("Incorrect key password", password);
                    throw new LuciaError("AUTH_INVALID_PASSWORD");
                }
                debug.key.notice("Validated key password");
            }
            else {
                debug.key.info("No password included in key");
            }
            if (singleUse) {
                debug.key.info("Key type: single-use");
                const withinExpiration = isWithinExpiration(databaseKeyData.expires);
                if (!withinExpiration) {
                    debug.key.fail(`Key expired at ${new Date(databaseKeyData.expires).toLocaleDateString()}`, keyId);
                    throw new LuciaError("AUTH_EXPIRED_KEY");
                }
                await this.adapter.deleteNonPrimaryKey(databaseKeyData.id);
            }
            else {
                debug.key.info("Key type: persistent");
            }
            debug.key.success("Validated key", keyId);
            const key = transformDatabaseKey(databaseKeyData);
            return key;
        }
        catch (e) {
            if (e instanceof LuciaError && e.message === "AUTH_EXPIRED_KEY") {
                await this.adapter.deleteNonPrimaryKey(databaseKeyData.id);
            }
            throw e;
        }
    };
    getSession = async (sessionId) => {
        if (sessionId.length !== 40) {
            debug.session.fail("Expected id length to be 40", sessionId);
            throw new LuciaError("AUTH_INVALID_SESSION_ID");
        }
        const databaseSession = await this.adapter.getSession(sessionId);
        if (!databaseSession) {
            debug.session.fail("Session not found", sessionId);
            throw new LuciaError("AUTH_INVALID_SESSION_ID");
        }
        const session = validateDatabaseSession(databaseSession);
        if (!session) {
            debug.session.fail(`Session expired at ${new Date(Number(databaseSession.idle_expires))}`, sessionId);
            if (this.autoDatabaseCleanup) {
                await this.adapter.deleteSession(sessionId);
            }
            throw new LuciaError("AUTH_INVALID_SESSION_ID");
        }
        return session;
    };
    getAllUserSessions = async (userId) => {
        // validate user id
        await this.getUser(userId);
        const databaseData = await this.adapter.getSessionsByUserId(userId);
        const validStoredUserSessions = databaseData
            .map((databaseSession) => {
            return validateDatabaseSession(databaseSession);
        })
            .filter((session) => session !== null);
        const deadStoredUserSessionIds = databaseData
            .map((databaseSession) => {
            return databaseSession.id;
        })
            .filter((sessionId) => {
            return !validStoredUserSessions.some((validSession) => validSession.sessionId === sessionId);
        });
        if (deadStoredUserSessionIds.length > 0) {
            await Promise.all(deadStoredUserSessionIds.map((deadSessionId) => this.adapter.deleteSession(deadSessionId)));
        }
        return validStoredUserSessions;
    };
    validateSession = async (sessionId) => {
        const session = await this.getSession(sessionId);
        if (session.state === "active") {
            debug.session.success("Validated session", session.sessionId);
            return session;
        }
        const renewedSession = await this.renewSession(sessionId);
        return renewedSession;
    };
    validateSessionUser = async (sessionId) => {
        const { session, user } = await this.getSessionUser(sessionId);
        if (session.state === "active") {
            debug.session.success("Validated session", session.sessionId);
            return { session, user };
        }
        const renewedSession = await this.renewSession(sessionId);
        return {
            session: renewedSession,
            user
        };
    };
    generateSessionId = () => {
        const sessionId = generateRandomString(40);
        const activePeriodExpiresAt = new Date(new Date().getTime() + this.sessionExpiresIn.activePeriod);
        const idlePeriodExpiresAt = new Date(activePeriodExpiresAt.getTime() + this.sessionExpiresIn.idlePeriod);
        return [sessionId, activePeriodExpiresAt, idlePeriodExpiresAt];
    };
    createSession = async (userId) => {
        const [sessionId, activePeriodExpiresAt, idlePeriodExpiresAt] = this.generateSessionId();
        await Promise.all([
            this.adapter.setSession({
                id: sessionId,
                user_id: userId,
                active_expires: activePeriodExpiresAt.getTime(),
                idle_expires: idlePeriodExpiresAt.getTime()
            }),
            this.autoDatabaseCleanup
                ? await this.deleteDeadUserSessions(userId)
                : null
        ]);
        return {
            userId,
            activePeriodExpiresAt,
            sessionId,
            idlePeriodExpiresAt,
            state: "active",
            fresh: true
        };
    };
    renewSession = async (sessionId) => {
        if (sessionId.length !== 40) {
            debug.session.fail("Expected id length to be 40", sessionId);
            throw new LuciaError("AUTH_INVALID_SESSION_ID");
        }
        const databaseSession = await this.adapter.getSession(sessionId);
        if (!databaseSession) {
            debug.session.fail("Session not found", sessionId);
            throw new LuciaError("AUTH_INVALID_SESSION_ID");
        }
        const session = validateDatabaseSession(databaseSession);
        if (!session) {
            debug.session.fail(`Session expired at ${new Date(Number(databaseSession.idle_expires)).toLocaleDateString()}`, sessionId);
            if (this.autoDatabaseCleanup) {
                await this.adapter.deleteSession(sessionId);
            }
            throw new LuciaError("AUTH_INVALID_SESSION_ID");
        }
        const [renewedSession] = await Promise.all([
            await this.createSession(session.userId),
            this.autoDatabaseCleanup
                ? await this.deleteDeadUserSessions(session.userId)
                : null
        ]);
        debug.session.success("Session renewed", renewedSession.sessionId);
        return renewedSession;
    };
    invalidateSession = async (sessionId) => {
        await this.adapter.deleteSession(sessionId);
        debug.session.notice("Invalidated session", sessionId);
    };
    invalidateAllUserSessions = async (userId) => {
        await this.adapter.deleteSessionsByUserId(userId);
    };
    deleteDeadUserSessions = async (userId) => {
        const databaseSessions = await this.adapter.getSessionsByUserId(userId);
        const deadSessionIds = databaseSessions
            .filter((databaseSession) => {
            return validateDatabaseSession(databaseSession) === null;
        })
            .map((databaseSession) => databaseSession.id);
        if (deadSessionIds.length === 0)
            return;
        await Promise.all(deadSessionIds.map((deadSessionId) => {
            this.adapter.deleteSession(deadSessionId);
        }));
    };
    parseRequestHeaders = (request) => {
        debug.request.init(request.method ?? "<method>", request.url ?? "<url>");
        if (request.method === null) {
            debug.request.fail("Request method unavailable");
            throw new LuciaError("AUTH_INVALID_REQUEST");
        }
        if (request.url === null) {
            debug.request.fail("Request url unavailable");
            throw new LuciaError("AUTH_INVALID_REQUEST");
        }
        const cookies = parseCookie(request.headers.cookie ?? "");
        const sessionId = cookies[SESSION_COOKIE_NAME] ?? null;
        if (sessionId) {
            debug.request.info("Found session cookie", sessionId);
        }
        else {
            debug.request.info("No session cookie found");
        }
        const csrfCheck = request.method.toUpperCase() !== "GET" &&
            request.method.toUpperCase() !== "HEAD";
        if (csrfCheck && this.csrfProtection) {
            const requestOrigin = request.headers.origin;
            if (!requestOrigin) {
                debug.request.fail("No request origin available");
                throw new LuciaError("AUTH_INVALID_REQUEST");
            }
            try {
                const url = new URL(request.url);
                if (![url.origin, ...this.origin].includes(requestOrigin)) {
                    debug.request.fail("Invalid request origin", requestOrigin);
                    throw new LuciaError("AUTH_INVALID_REQUEST");
                }
                debug.request.info("Valid request origin", requestOrigin);
            }
            catch {
                debug.request.fail("Invalid origin string", requestOrigin);
                // failed to parse url
                throw new LuciaError("AUTH_INVALID_REQUEST");
            }
        }
        else {
            debug.request.notice("Skipping CSRF check");
        }
        return sessionId;
    };
    handleRequest = (
    // cant reference middleware type with Lucia.Auth
    ...args) => {
        const middleware = this.middleware;
        return new AuthRequest(this, middleware(...[...args, this.env]));
    };
    createSessionCookie = (session) => {
        return createSessionCookie(session, this.env, this.sessionCookieOption);
    };
    createKey = async (userId, keyData) => {
        const keyId = `${keyData.providerId}:${keyData.providerUserId}`;
        let hashedPassword = null;
        if (keyData.password !== null) {
            hashedPassword = await this.hash.generate(keyData.password);
        }
        if (keyData.type === "persistent") {
            await this.adapter.setKey({
                id: keyId,
                user_id: userId,
                hashed_password: hashedPassword,
                primary_key: false,
                expires: null
            });
            return {
                type: "persistent",
                providerId: keyData.providerId,
                providerUserId: keyData.providerUserId,
                primary: false,
                passwordDefined: !!keyData.password,
                userId
            };
        }
        const expiresAt = getOneTimeKeyExpiration(keyData.expiresIn);
        if (expiresAt == null) {
            throw new LuciaError("UNKNOWN_ERROR");
        }
        await this.adapter.setKey({
            id: keyId,
            user_id: userId,
            hashed_password: hashedPassword,
            primary_key: false,
            expires: expiresAt.getTime()
        });
        return {
            type: "single_use",
            providerId: keyData.providerId,
            providerUserId: keyData.providerUserId,
            userId,
            expiresAt,
            expired: !isWithinExpiration(keyData.expiresIn),
            passwordDefined: !!keyData.password
        };
    };
    deleteKey = async (providerId, providerUserId) => {
        const keyId = `${providerId}:${providerUserId}`;
        await this.adapter.deleteNonPrimaryKey(keyId);
    };
    getKey = async (providerId, providerUserId) => {
        const keyId = `${providerId}:${providerUserId}`;
        const shouldDataBeDeleted = async () => false;
        const databaseKey = await this.adapter.getKey(keyId, shouldDataBeDeleted);
        if (!databaseKey) {
            throw new LuciaError("AUTH_INVALID_KEY_ID");
        }
        const key = transformDatabaseKey(databaseKey);
        return key;
    };
    getAllUserKeys = async (userId) => {
        // validate user id
        await this.getUser(userId);
        const databaseKeys = await this.adapter.getKeysByUserId(userId);
        return databaseKeys.map((dbKey) => transformDatabaseKey(dbKey));
    };
    updateKeyPassword = async (providerId, providerUserId, password) => {
        const keyId = `${providerId}:${providerUserId}`;
        let updatedDatabaseKey;
        if (password === null) {
            updatedDatabaseKey = await this.adapter.updateKeyPassword(keyId, null);
        }
        else {
            const hashedPassword = await this.hash.generate(password);
            updatedDatabaseKey = await this.adapter.updateKeyPassword(keyId, hashedPassword);
        }
        if (updatedDatabaseKey)
            return;
        // validate key
        await this.getKey(providerId, providerUserId);
    };
}
